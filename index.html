<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>CHRISTMAS - PHOTOS TREE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: sans-serif; cursor: none; }
        
        #info {
            position: absolute; top: 10px; left: 10px; color: #B8860B; 
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; border: 1px solid #B8860B;
            box-shadow: 0 0 15px rgba(184, 134, 11, 0.2);
            z-index: 200;
        }
        h3 { margin: 0 0 5px 0; color: #fff; font-size: 16px; }
        p  { margin: 5px 0; font-size: 14px; color: #ddd; }

        /* é¡¶éƒ¨å›ºå®šçš„ 2D æ–‡æœ¬ */
        #title-text {
            position: absolute;
            top: 18px;
            left: 50%;
            transform: translateX(-50%);
            color: #FDF4D3;
            font-size: 32px;
            font-weight: bold;
            letter-spacing: 0.35em;
            text-transform: uppercase;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.9);
            pointer-events: none;
            z-index: 180;
        }
        
        #video-container {
            position: absolute;
            bottom: 20px; 
            right: 20px;
            width: 160px; 
            height: 120px;
            border: 2px solid rgba(184, 134, 11, 0.5); 
            border-radius: 8px; 
            overflow: hidden; 
            z-index: 9999;
            opacity: 0.7;
        }

        #video-container video,
        #video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #B8860B; font-size: 20px; text-align: center;
            pointer-events: none; letter-spacing: 1px;
            z-index: 200;
        }

        #selection-tip {
             position: absolute; top: 15%; left: 50%;
             transform: translateX(-50%);
             color: #fff; background: rgba(0,0,0,0.6);
             padding: 10px 20px; border-radius: 30px;
             display: none; pointer-events: none;
             border: 1px solid #B8860B;
             font-size: 16px; text-shadow: 0 0 5px gold;
             z-index: 100;
        }

        #hand-cursor {
            position: absolute; width: 40px; height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 15px #ffd700;
            pointer-events: none; z-index: 999;
            transform: translate(-50%, -50%);
            display: none; transition: width 0.2s, height 0.2s;
        }
        .cursor-active {
            width: 60px !important; height: 60px !important;
            border-color: #ffd700 !important;
            background: rgba(255, 215, 0, 0.2) !important;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨é›•åˆ»é‡‘è‰²åœ£è¯æ ‘...<br>è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>

    <!-- é¡¶éƒ¨å›ºå®šè‹±æ–‡ -->
    <div id="title-text">MERRY CHRISTMAS</div>

    <div id="info">
        <h3>ğŸ„ é­”æ³•æ“ä½œæŒ‡å—</h3>
        <p>âœŠ <b>æ¡æ‹³</b>ï¼šèšæ‹¢æˆæ ‘</p>
        <p>ğŸ– <b>å¼ æ‰‹</b>ï¼šæ•£å¼€æˆç²’å­</p>
        <p>ğŸ‘Œ <b>OK æ‰‹åŠ¿</b>ï¼šåœ¨æ•£å¼€çŠ¶æ€ä¸‹åˆ‡å‡ºä¸€å¼ ç…§ç‰‡</p>
    </div>
    
    <div id="video-container">
        <video id="webcam" playsinline></video>
        <canvas id="hand-overlay"></canvas>
    </div>
    <div id="selection-tip"></div>
    <div id="hand-cursor"></div>

    <script>
        // ================= é…ç½®åŒº =================

        // 1ï¼‰ä½ è‡ªå·±çš„ç…§ç‰‡è·¯å¾„ï¼ˆåå­—è¦å’Œ assets é‡Œä¸€æ¨¡ä¸€æ ·ï¼‰
        const IMAGE_URLS = [
          './assets/1.jpg',
          './assets/2.jpg',
          './assets/3.jpg',
          './assets/4.jpg',
          './assets/5.jpg',
          './assets/6.jpg',
          './assets/7.jpg',
          './assets/8.jpg',
          './assets/9.jpg',
          './assets/10.jpg'
        ];

        // 2ï¼‰ç…§ç‰‡æ•°é‡ï¼Œç›´æ¥ç”¨æ•°ç»„é•¿åº¦ï¼Œä¸å†æ‰‹å†™ 16
        const PHOTO_COUNT = IMAGE_URLS.length;

        const ORNAMENT_COUNT = 2200;  // è£…é¥°æ•°é‡ï¼ˆçƒ + æ–¹å—ï¼‰

        const COLOR_GOLD  = 0xEBC46B; // æ·±ä¸€ç‚¹çš„é‡‘è‰²
        const COLOR_GOLD2 = 0xC89A3A; // ç›¸æ¡†æ›´å¤é“œä¸€ç‚¹
        const COLOR_RED   = 0xC04040;
        const COLOR_GREEN = 0x3FA85A; // äº®ä¸€äº›çš„åœ£è¯ç»¿

        // æ ‘æ•´ä½“å¤§å°
        const TREE_HEIGHT = 100;
        const TREE_RADIUS = 35;

        // åœ°é¢é«˜åº¦
        const GROUND_Y = -TREE_HEIGHT * 0.5 - 6;

        // æ•£å¼€æ—¶çš„åŠå¾„ï¼ˆç‚¸å¼€çš„èŒƒå›´ï¼‰
        const SCATTER_MAX_RADIUS = 215;
        const SCATTER_MIN_FACTOR = 0.15; // è¶Šå¤§è¶Šâ€œèšæ‹¢â€

        // å®é™…å¯ç”¨çš„ç…§ç‰‡æ•°é‡ï¼ˆä¸ä¼šé‡å¤ï¼‰
        let EFFECTIVE_PHOTO_COUNT = PHOTO_COUNT;

        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, composer;
        let particles = []; 
        let ornaments = []; 
        let starMesh;
        let bgStars;
        let groundMesh;
        let snowFlakes = [];

        let raycaster = new THREE.Raycaster(); 
        let mouse = new THREE.Vector2(); 
        
        const selectionTip = document.getElementById('selection-tip');
        const cursor = document.getElementById('hand-cursor');

        const overlayCanvas = document.getElementById('hand-overlay');
        const overlayCtx = overlayCanvas.getContext('2d');

        function resizeOverlay() {
            const rect = document.getElementById('video-container').getBoundingClientRect();
            overlayCanvas.width = rect.width;
            overlayCanvas.height = rect.height;
        }
        resizeOverlay();
        window.addEventListener('resize', resizeOverlay);

        // çŠ¶æ€
        let isTreeForm = true;      
        let photoCycleIndex = -1;      // OK åˆ‡æ¢çš„ç´¢å¼•
        let selectedPhotoIndex = -1;   // å½“å‰è¢«â€œæ”¾å¤§å±•ç¤ºâ€çš„é‚£ä¸€å¼ 

        let handMode = 'tree';          // 'tree' èšæ‹¢, 'browse' æ•£å¼€
        let openFrames = 0;
        let fistFrames = 0;
        const SWITCH_FRAMES = 4;
        let lastOkState = false;

        // ==== è§†è§’ï¼ˆæ‰‹ = çœ¼ç›ï¼‰ï¼šæ‘„åƒæœºç»•æ ‘è½¬ ====
        const VIEW_CENTER = new THREE.Vector3(0, 10, 0); // çœ‹å‘çš„ä¸­å¿ƒç‚¹
        let viewYaw   = 0;
        let viewPitch = 0.3;
        let viewRadius = 175;

        let targetYaw   = 0;
        let targetPitch = 0.3;
        let targetRadius = 175;

        // ================= THREE åœºæ™¯åˆå§‹åŒ– =================
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020308);
            scene.fog = new THREE.FogExp2(0x000000, 0.0012);

            camera = new THREE.PerspectiveCamera(68, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, VIEW_CENTER.y, viewRadius);
            camera.lookAt(VIEW_CENTER);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.7;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x555555, 1.0);
            scene.add(ambient);
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
            mainLight.position.set(40, 80, 80);
            scene.add(mainLight);
            const goldLight = new THREE.PointLight(COLOR_GOLD, 1.2, 450);
            goldLight.position.set(0, 90, 40);
            scene.add(goldLight);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.4,
                0.25,
                0.2
            );
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // createBackgroundStars(); // éœ€è¦çš„è¯å¯ä»¥æ‰“å¼€
            createElements();
            createGround();
            createSnow();
            createStar();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // ============ åœ°é¢ï¼ˆé›ªåœ°åœ†ç›˜ï¼‰ ============
        function createGround() {
            const geo = new THREE.CircleGeometry(220, 64);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x0b0b10,
                emissive: 0xffffff,
                emissiveIntensity: 0.06,
                roughness: 0.95,
                metalness: 0.0,
                side: THREE.DoubleSide
            });

            groundMesh = new THREE.Mesh(geo, mat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.position.y = GROUND_Y;
            scene.add(groundMesh);
        }

        // ============ é›ªèŠ±ï¼šä¼šè·Ÿæ ‘ä¸€èµ·èšæ‹¢ / æ•£å¼€ ============
        function createSnow() {
            const snowGeo = new THREE.SphereGeometry(0.7, 10, 10);
            const baseMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.4,
                roughness: 0.9,
                metalness: 0.0
            });

            const totalSnow = 2000;

            for (let i = 0; i < totalSnow; i++) {
                const mat = baseMat.clone();
                const snow = new THREE.Mesh(snowGeo, mat);

                const isGroundSnow = i < totalSnow * 0.6; // 60% åœ°é¢é›ª

                if (isGroundSnow) {
                    // æ ‘å½¢æ€ä¸‹ï¼šåœ°é¢ä¸Šçš„é›ª
                    const r = 160 * Math.sqrt(Math.random());
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const y = GROUND_Y + Math.random() * 3.0;
                    snow.userData.treePos = new THREE.Vector3(x, y, z);

                    // æ•£å¼€å½¢æ€ï¼šè¿˜æ˜¯è´´åœ°ï¼Œåªæ˜¯åŠå¾„æ›´å¤§
                    const sr = 220 * Math.sqrt(Math.random());
                    const sAngle = Math.random() * Math.PI * 2;
                    const sx = Math.cos(sAngle) * sr;
                    const sz = Math.sin(sAngle) * sr;
                    const sy = GROUND_Y + Math.random() * 4.0;
                    snow.userData.scatterPos = new THREE.Vector3(sx, sy, sz);

                } else {
                    // ç©ºä¸­é›ª
                    const r = 140 * Math.random();
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * r;
                    const z = Math.sin(angle) * r;
                    const y = GROUND_Y + Math.random() * (TREE_HEIGHT + 60);
                    snow.userData.treePos = new THREE.Vector3(x, y, z);

                    // æ•£å¼€å½¢æ€ï¼šä¸‰ç»´äº‘å›¢
                    const scatterMaxR = SCATTER_MAX_RADIUS;
                    const minR = scatterMaxR * SCATTER_MIN_FACTOR;
                    const rr = minR + Math.random() * (scatterMaxR - minR);
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    const sx = VIEW_CENTER.x + rr * Math.sin(phi) * Math.cos(theta);
                    const sy = VIEW_CENTER.y + rr * Math.sin(phi) * Math.sin(theta);
                    const sz = VIEW_CENTER.z + rr * Math.cos(phi);

                    snow.userData.scatterPos = new THREE.Vector3(sx, sy, sz);
                }

                snow.userData.velocity = 0.06 + Math.random() * 0.06;
                snow.position.copy(snow.userData.scatterPos);

                scene.add(snow);
                snowFlakes.push(snow);
            }
        }

        // èƒŒæ™¯æ˜Ÿç©ºï¼ˆå¯é€‰ï¼‰
        function createBackgroundStars() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = 4000;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const rangeX = 260;
                const rangeY = 220;
                const rangeZ = 260;

                const x = (Math.random() - 0.5) * rangeX;
                const y = (Math.random() - 0.2) * rangeY;
                const z = (Math.random() - 0.3) * rangeZ;

                positions[i * 3]     = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }

            starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const starMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.4,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9
            });

            bgStars = new THREE.Points(starGeo, starMat);
            scene.add(bgStars);
        }

        function createElements() {
            const textureLoader = new THREE.TextureLoader();
            const textures = IMAGE_URLS.map(url => textureLoader.load(url));

            // æ¯å¼ åªç”¨ä¸€æ¬¡ï¼Œä¸é‡å¤
            EFFECTIVE_PHOTO_COUNT = IMAGE_URLS.length;

            const photoGeo = new THREE.PlaneGeometry(4.5, 6);
            const frameGeo = new THREE.PlaneGeometry(5.1, 6.8);
            const frameMat = new THREE.MeshStandardMaterial({
                color: COLOR_GOLD2,
                metalness: 0.85,
                roughness: 0.4
            });

            // ç…§ç‰‡ç²’å­
            for (let i = 0; i < EFFECTIVE_PHOTO_COUNT; i++) {
                const photoMat = new THREE.MeshStandardMaterial({
                    map: textures[i],
                    side: THREE.DoubleSide
                });
                const group = new THREE.Group();
                group.add(new THREE.Mesh(photoGeo, photoMat));
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.position.z = -0.06;
                group.add(frame);

                setupTreePosition(group, i, EFFECTIVE_PHOTO_COUNT, TREE_HEIGHT, TREE_RADIUS * 0.9, false);
                group.userData.id = i;
                group.userData.baseScale = 0.9;
                scene.add(group);
                particles.push(group);
            }

            // è£…é¥°ç²’å­ï¼šçƒ + å°æ–¹å—
            const orbSphereGeo = new THREE.SphereGeometry(1.4, 20, 20);
            const orbCubeGeo   = new THREE.BoxGeometry(1.6, 1.6, 1.6);

            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const shapeRand = Math.random();
                let geometry;
                let color;

                if (shapeRand < 0.8) {
                    geometry = orbSphereGeo;
                    const r = Math.random();
                    if (r < 0.3)       color = COLOR_GOLD;
                    else if (r < 0.6)  color = COLOR_RED;
                    else               color = COLOR_GREEN;
                } else {
                    geometry = orbCubeGeo;
                    color = COLOR_GREEN;
                }

                const mat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2 + Math.random() * 0.25,
                    roughness: 0.35,
                    metalness: 0.9
                });

                const mesh = new THREE.Mesh(geometry, mat);

                setupTreePosition(mesh, i, ORNAMENT_COUNT, TREE_HEIGHT + 5, TREE_RADIUS, true);
                mesh.userData.baseIntensity = 0.2 + Math.random() * 0.25;
                mesh.userData.sparkleSpeed = Math.random() * 0.10 + 0.04;
                scene.add(mesh);
                ornaments.push(mesh);
            }
        }

        // æ ‘èº«ï¼šé«˜ç˜¦é”¥å½¢ï¼›æ•£å¼€ï¼šå…¨å±äº‘å›¢
        function setupTreePosition(obj, index, total, height, maxRadius, isOrb) {
            const t = index / total;

            const layerCount = 80;
            const layerIndex = Math.floor(t * layerCount);
            const layerT = layerIndex / layerCount;
            const yBase = layerT * height - height * 0.5;
            const yJitter = (Math.random() - 0.5) * (height / layerCount) * 0.8;
            const treeY = yBase + yJitter;

            const radiusBase = Math.pow(1 - layerT, 1.3) * maxRadius;
            const radiusJitter = (Math.random() - 0.5) * 3.0;
            const radius = Math.max(0, radiusBase + radiusJitter) * (isOrb ? 1.0 : 0.9);

            const angle = Math.random() * Math.PI * 2;

            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            obj.userData.treePos = new THREE.Vector3(x, treeY, z);

            const scatterMaxR = SCATTER_MAX_RADIUS;
            const minR = scatterMaxR * SCATTER_MIN_FACTOR;
            const rr = minR + Math.random() * (scatterMaxR - minR);

            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);

            const sx = VIEW_CENTER.x + rr * Math.sin(phi) * Math.cos(theta);
            const sy = VIEW_CENTER.y + rr * Math.sin(phi) * Math.sin(theta);
            const sz = VIEW_CENTER.z + rr * Math.cos(phi);

            obj.userData.scatterPos = new THREE.Vector3(sx, sy, sz);
            obj.userData.velocity = 0.06 + Math.random() * 0.06;
            obj.position.copy(obj.userData.scatterPos);
        }

        // é¡¶ç«¯äº”è§’æ˜Ÿ
        function createStar() {
            const starShape = new THREE.Shape();
            const outerR = 6;
            const innerR = 2.7;
            const points = 5;

            for (let i = 0; i < points * 2; i++) {
                const isOuter = (i % 2 === 0);
                const r = isOuter ? outerR : innerR;
                const angle = (i / (points * 2)) * Math.PI * 2 - Math.PI / 2;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) starShape.moveTo(x, y);
                else starShape.lineTo(x, y);
            }
            starShape.closePath();

            const starGeo2D = new THREE.ShapeGeometry(starShape);
            const starMat = new THREE.MeshStandardMaterial({
                color: 0xFFF6D0,
                emissive: 0xFFF6D0,
                emissiveIntensity: 2.0,
                roughness: 0.15,
                metalness: 0.9,
                side: THREE.DoubleSide
            });

            const star1 = new THREE.Mesh(starGeo2D, starMat);
            const star2 = new THREE.Mesh(starGeo2D, starMat.clone());
            star2.rotation.y = Math.PI / 2;

            const starGroup = new THREE.Group();
            starGroup.add(star1);
            starGroup.add(star2);

            const starY = TREE_HEIGHT * 0.5 + 12;
            starGroup.position.set(0, starY, 0);

            starMesh = starGroup;
            scene.add(starMesh);
        }

        // ================= åŠ¨ç”»ä¸äº¤äº’æ ¸å¿ƒ =================
        function animate(time) {
            requestAnimationFrame(animate);

            // æ‰‹ = çœ¼ç›ï¼šæ‘„åƒæœºç»•æ ‘è½¬ + è¿œè¿‘
            viewYaw    = THREE.MathUtils.lerp(viewYaw,   targetYaw,   0.2);
            viewPitch  = THREE.MathUtils.lerp(viewPitch, targetPitch, 0.2);
            viewRadius = THREE.MathUtils.lerp(viewRadius, targetRadius, 0.2);

            const cp = new THREE.Vector3();
            cp.x = VIEW_CENTER.x + viewRadius * Math.sin(viewYaw) * Math.cos(viewPitch);
            cp.z = VIEW_CENTER.z + viewRadius * Math.cos(viewYaw) * Math.cos(viewPitch);
            cp.y = VIEW_CENTER.y + viewRadius * Math.sin(viewPitch);

            camera.position.copy(cp);
            camera.lookAt(VIEW_CENTER);

            if (starMesh) {
                starMesh.rotation.y -= 0.02;
            }
            if (bgStars) {
                bgStars.rotation.y += 0.0006;
            }

            // ç…§ç‰‡ç²’å­ï¼šæ•£å¼€ + OK æ—¶é£åˆ°é•œå¤´å‰
            particles.forEach(group => {
                const id = group.userData.id;
                const isSelected = (!isTreeForm && id === selectedPhotoIndex);

                let targetPos, targetScale;

                if (isSelected) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    const worldTarget = camera.position.clone().add(dir.multiplyScalar(40));

                    targetPos = worldTarget;
                    targetScale = 4.5;

                    group.children[1].material.emissive.setHex(0xffffff);
                    group.children[1].material.emissiveIntensity = 1.2;

                    group.quaternion.copy(camera.quaternion);
                    group.position.lerp(targetPos, 0.18);
                } else {
                    targetPos = isTreeForm ? group.userData.treePos : group.userData.scatterPos;
                    targetScale = group.userData.baseScale;

                    group.children[1].material.emissive.setHex(0x221100);
                    group.children[1].material.emissiveIntensity = 0.3;

                    group.lookAt(camera.position);
                    group.position.lerp(targetPos, group.userData.velocity);
                }

                const currentScale = group.scale.x;
                const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.12);
                group.scale.set(newScale, newScale, newScale);
            });

            ornaments.forEach(mesh => {
                const target = isTreeForm ? mesh.userData.treePos : mesh.userData.scatterPos;
                mesh.position.lerp(target, mesh.userData.velocity);
                mesh.material.emissiveIntensity = mesh.userData.baseIntensity;
            });

            snowFlakes.forEach(flake => {
                const target = isTreeForm ? flake.userData.treePos : flake.userData.scatterPos;
                flake.position.lerp(target, flake.userData.velocity);
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            resizeOverlay();
        }

        // ============ å…¬ç”¨ï¼šå…³é”®ç‚¹è·ç¦» ============
        function landmarkDist(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dz = (a.z || 0) - (b.z || 0);
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }

        // ================= æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ =================
        const loadingElement = document.getElementById('loading');
        const videoElement = document.getElementById('webcam');

        function getHandState(landmarks) {
            const wrist  = landmarks[0];
            const thumb  = landmarks[4];
            const index  = landmarks[8];
            const middle = landmarks[12];
            const ring   = landmarks[16];
            const pinky  = landmarks[20];

            const pinch = landmarkDist(thumb, index);

            const tipDists = [
                landmarkDist(wrist, index),
                landmarkDist(wrist, middle),
                landmarkDist(wrist, ring),
                landmarkDist(wrist, pinky)
            ];
            const avgTipDist = tipDists.reduce((a,b) => a + b, 0) / tipDists.length;

            const spreadIndexMiddle = landmarkDist(index, middle);

            const isOk = pinch < 0.055 && avgTipDist > 0.20 && spreadIndexMiddle > 0.06;
            if (isOk) return 'ok';

            if (avgTipDist > 0.22) return 'open';
            if (avgTipDist < 0.16) return 'fist';

            return 'neutral';
        }

        function onHandsResults(results) {
            loadingElement.style.display = 'none';

            overlayCtx.save();
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            overlayCtx.translate(overlayCanvas.width, 0);
            overlayCtx.scale(-1, 1);

            if (results.image) {
                overlayCtx.drawImage(results.image, 0, 0, overlayCanvas.width, overlayCanvas.height);
            }

            const handLandmarksList = results.multiHandLandmarks;

            if (handLandmarksList && handLandmarksList.length > 0) {
                const landmarks = handLandmarksList[0];

                drawConnectors(overlayCtx, landmarks, HAND_CONNECTIONS, {
                    color: '#00FF00',
                    lineWidth: 2
                });

                const state = getHandState(landmarks);

                // ------- 1ï¼‰OK æ‰‹åŠ¿ï¼šåˆ‡ç…§ç‰‡ -------
                if (state === 'ok') {
                    openFrames = 0;
                    fistFrames = 0;

                    if (!lastOkState) {
                        handMode = 'browse';
                        isTreeForm = false;

                        if (EFFECTIVE_PHOTO_COUNT > 0) {
                            photoCycleIndex = (photoCycleIndex + 1) % EFFECTIVE_PHOTO_COUNT;
                            selectedPhotoIndex = photoCycleIndex;

                            selectionTip.style.display = 'block';
                            selectionTip.innerText = `ğŸ MERRY CHRISTMAS! ç…§ç‰‡ #${selectedPhotoIndex + 1}`;
                        }
                    }
                    lastOkState = true;
                } else {
                    lastOkState = false;

                    // æ¾å¼€ OKï¼šç…§ç‰‡å›å»
                    selectedPhotoIndex = -1;
                    selectionTip.style.display = 'none';

                    // ------- 2ï¼‰å¼ æ‰‹ / æ¡æ‹³ æ§åˆ¶æ ‘å½¢æ€ -------
                    if (state === 'open') {
                        openFrames++;
                        fistFrames = 0;
                    } else if (state === 'fist') {
                        fistFrames++;
                        openFrames = 0;
                    } else {
                        openFrames = 0;
                        fistFrames = 0;
                    }

                    if (openFrames >= SWITCH_FRAMES && handMode !== 'browse') {
                        handMode = 'browse';
                    } else if (fistFrames >= SWITCH_FRAMES && handMode !== 'tree') {
                        handMode = 'tree';
                    }
                }

                // handMode å†³å®šæ˜¯å¦èšæ‹¢
                if (handMode === 'browse') {
                    isTreeForm = false;
                } else {
                    isTreeForm = true;
                    selectedPhotoIndex = -1;
                    selectionTip.style.display = 'none';
                }

                // ------- 3ï¼‰æ‰‹ = è§†è§’ï¼šå·¦å³ / ä¸Šä¸‹ / è¿œè¿‘ -------
                const wrist = landmarks[0];

                // å·¦å³æ—‹è½¬
                const xOffset = 0.5 - wrist.x;
                const yawRange = Math.PI * 1.5;
                targetYaw = xOffset * yawRange;

                // ä¸Šä¸‹ä¿¯ä»°
                const yOffset = 0.55 - wrist.y;
                const pitchRange = Math.PI * 0.25;
                targetPitch = THREE.MathUtils.clamp(
                    yOffset * pitchRange + 0.08, 
                    -Math.PI*0.3, 
                    Math.PI*0.3
                );

                // ==== ç”¨æ‰‹çš„â€œå¤§å°â€æ§åˆ¶è¿œè¿‘ â€”â€” ä»…åœ¨æ•£å¼€(browse)çŠ¶æ€ä¸‹ç”Ÿæ•ˆ ====
                const index  = landmarks[8];
                const middle = landmarks[12];
                const ring   = landmarks[16];
                const pinky  = landmarks[20];

                const tipDists = [
                    landmarkDist(wrist, index),
                    landmarkDist(wrist, middle),
                    landmarkDist(wrist, ring),
                    landmarkDist(wrist, pinky)
                ];
                const avgTipDist = tipDists.reduce((a, b) => a + b, 0) / tipDists.length;

                if (handMode === 'browse') {
                    const minD = 0.15;
                    const maxD = 0.45;
                    const dClamped = THREE.MathUtils.clamp(avgTipDist, minD, maxD);
                    const tDepth = (dClamped - minD) / (maxD - minD); // 0 è¿œ 1 è¿‘

                    const farR  = 280;  // æ‰‹æœ€è¿œï¼šæ ‘æœ€å°
                    const nearR = 90;   // æ‰‹æœ€è¿‘ï¼šæ ‘æœ€å¤§
                    targetRadius = farR - tDepth * (farR - nearR);
                } else {
                    const TREE_VIEW_R = 175;
                    targetRadius = THREE.MathUtils.lerp(targetRadius, TREE_VIEW_R, 0.2);
                }

            } else {
                // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼šè¿˜åŸæˆæ ‘ï¼Œæ”¶èµ·ç…§ç‰‡ï¼Œè§†è§’æ…¢æ…¢å›é»˜è®¤
                isTreeForm = true;
                selectedPhotoIndex = -1;
                selectionTip.style.display = 'none';
                openFrames = 0;
                fistFrames = 0;
                lastOkState = false;

                const DEFAULT_R = 175;
                targetYaw = THREE.MathUtils.lerp(targetYaw, 0, 0.05);
                targetPitch = THREE.MathUtils.lerp(targetPitch, 0.3, 0.05);
                targetRadius = THREE.MathUtils.lerp(targetRadius, DEFAULT_R, 0.05);
            }

            overlayCtx.restore();
        }

        if (typeof Hands === 'undefined') {
             alert("MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œï¼");
        } else {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.3
            });
            hands.onResults(onHandsResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }
        
        initScene();

        // ================= å…¨å±é€»è¾‘ =================
        document.body.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            }
        });
        // é€€å‡ºå…¨å±ï¼šEsc

    </script>
</body>
</html>
